/*!
 * Analog Sensor API - GUI for OpenSprinkker App
 * https://github.com/opensprinklershop/
 * (c) 2024 OpenSprinklerShop
 * Released under the MIT License
 */

var analogSensors = {},
	progAdjusts = {},
	monitors = {},
	monitorAlerts = {},
	notificationsAllowed,
	notificationsNeedsGrant;


const CHARTS = 12;
const USERDEF_SENSOR = 49;
const USERDEF_UNIT = 99;
const SENSOR_MQTT = 90;

const CURRENT_FW = "2.3.3(168)";
const CURRENT_FW_ID = 231;
const CURRENT_FW_MIN = 150;

const COLORS = ["#F3B415", "#F27036", "#663F59", "#6A6E94", "#4E88B4", "#00A7C6", "#18D8D8", '#A9D794', '#46AF78', '#A93F55', '#8C5E58', '#2176FF', '#33A1FD', '#7A918D', '#BAFF29'];
const COLCOUNT = 15;

//detected Analog Sensor Boards:
const ASB_BOARD1 = 0x01;
const ASB_BOARD2 = 0x02;
const OSPI_PCF8591 = 0x04;
const OSPI_ADS1115 = 0x08;
const UART_SC16IS752 = 0x10;
const RS485_TRUEBNER1 = 0x20;
const RS485_TRUEBNER2 = 0x40;
const RS485_TRUEBNER3 = 0x80;
const RS485_TRUEBNER4 = 0x100;
const OSPI_USB_RS485 = 0x200;

function success_callback(scope) {
}


function asb_init() {
	if (isAndroid) {
		cordova.plugins.notification.local.createChannel({
			channelId:'os_low',
			channelName:'OpenSprinklerLowNotifications',
			vibrate: false, // bool (optional), default is false
			importance: 2, // int (optional) 0 to 4, default is IMPORTANCE_DEFAULT (3)
			soundUsage: 5 // int (optional), default is USAGE_NOTIFICATION
			}, success_callback, this);
		cordova.plugins.notification.local.createChannel({
			channelId:'os_med',
			channelName:'OpenSprinklerMedNotifications',
			vibrate: false, // bool (optional), default is false
			importance: 3, // int (optional) 0 to 4, default is IMPORTANCE_DEFAULT (3)
			soundUsage: 5 // int (optional), default is USAGE_NOTIFICATION
			}, success_callback, this);
		cordova.plugins.notification.local.createChannel({
			channelId:'os_high',
			channelName:'OpenSprinklerHighNotifications',
			vibrate: true, // bool (optional), default is false
			importance: 4, // int (optional) 0 to 4, default is IMPORTANCE_DEFAULT (3)
			soundUsage: 5 // int (optional), default is USAGE_NOTIFICATION
			}, success_callback, this);
	}
	if (isiOS || isAndroid) {
		cordova.plugins.notification.local.hasPermission(function (granted) {
			notificationsNeedsGrant = !granted;
			notificationsAllowed = granted;
		});
	} else {
		notificationsNeedsGrant = false;
		notificationsAllowed = true;
	}
}

function checkAnalogSensorAvail() {
	return controller.options && controller.options.feature === "ASB";
}

function refresh() {
	setTimeout(function () {
		location.reload();
	}, 100);
}

function enc(s) {
	//encodeURIComponent does not encode a single "%" !
	if (s) {
		return encodeURIComponent(s);
	}
	return s;
}

function updateProgramAdjustments(callback) {
	callback = callback || function () { };
	return sendToOS("/se?pw=", "json").then(function (data) {
		progAdjusts = data.progAdjust;
		callback();
	});
}

function updateMonitors(callback) {
	callback = callback || function () { };
	if (checkOSVersion(233)) {
		return sendToOS("/ml?pw=", "json").then(function (data) {

			monitors = data.monitors;
			callback();
		});
	} else callback();
}

function updateAnalogSensor(callback) {
	callback = callback || function () { };
	return sendToOS("/sl?pw=", "json").then(function (data) {
		analogSensors = data.sensors;
		analogSensors.expandItem = new Set(["sensors"]);
		if (data.hasOwnProperty("detected"))
			analogSensors.detected = data.detected;
		callback();
	});
}

function updateSensorShowArea(page) {
	if (checkAnalogSensorAvail()) {
		var showArea = page.find("#os-sensor-show");
		var html = "", i, j;
		html += "<div class='ui-body ui-body-a center'><table style='margin: 0px auto;'>";
		var cols = Math.round(window.innerWidth / 300);

		for (i = 0; i < progAdjusts.length; i++) {
			if (i % cols == 0) {
				if (i > 0)
					html += "</tr>";
				html += "<tr>";
			}
			html += "<td id='mainpageChart-" + i + "'/>";
		}
		if (i > 0)
			html += "</tr>";
		html += "</table></div>";

		if (checkOSVersion(233) && monitors) {
			for (i = 0; i < monitors.length; i